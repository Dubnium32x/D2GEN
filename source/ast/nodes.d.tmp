module ast.nodes;

import std.stdio;
import std.string;
import std.array;
import std.conv;

// Common AST node base class
class ASTNode {
    // For debugging and printing
    override string toString() const {
        return "ASTNode";
    }
}

// AST node for import declarations
class ImportDecl : ASTNode {
    string moduleName;
    
    this(string moduleName) {
        this.moduleName = moduleName;
    }
    
    override string toString() const {
        return "ImportDecl(" ~ moduleName ~ ")";
    }
}

// AST node for variable declarations
class VarDecl : ASTNode {
    string type;
    string name;
    ASTNode value;
    string visibility = "default";
    bool isConst = false;
    
    this(string type, string name, ASTNode value) {
        this.type = type;
        this.name = name;
        this.value = value;
    }
    
    override string toString() const {
        return "VarDecl(" ~ type ~ ", " ~ name ~ ")";
    }
}

// AST node for arrays [1, 2, 3] or []
class ArrayLiteral : ASTNode {
    ASTNode[] elements;
    
    this(ASTNode[] elements) {
        this.elements = elements;
    }
    
    override string toString() const {
        string result = "ArrayLiteral([";
        foreach (i, e; elements) {
            if (i > 0) result ~= ", ";
            result ~= e.toString();
        }
        result ~= "])";
        return result;
    }
}

// AST node for array declarations
class ArrayDecl : ASTNode {
    string type;
    string name;
    ASTNode[] elements;
    
    this(string type, string name, ASTNode[] elements) {
        this.type = type;
        this.name = name;
        this.elements = elements;
    }
    
    override string toString() const {
        return "ArrayDecl(" ~ type ~ ", " ~ name ~ ")";
    }
}

// AST node for integer literals
class IntLiteral : ASTNode {
    int value;
    
    this(int value) {
        this.value = value;
    }
    
    override string toString() const {
        return "IntLiteral(" ~ to!string(value) ~ ")";
    }
}

// AST node for boolean literals
class BoolLiteral : ASTNode {
    bool value;
    
    this(bool value) {
        this.value = value;
    }
    
    override string toString() const {
        return "BoolLiteral(" ~ to!string(value) ~ ")";
    }
}

// AST node for string literals
class StringLiteral : ASTNode {
    string value;
    
    this(string value) {
        this.value = value;
    }
    
    override string toString() const {
        return "StringLiteral(\"" ~ value ~ "\")";
    }
}

// AST node for variable references
class VarExpr : ASTNode {
    string name;
    
    this(string name) {
        this.name = name;
    }
    
    override string toString() const {
        return name;
    }
}

// AST node for unary expressions (e.g., !expr, -expr)
class UnaryExpr : ASTNode {
    string op;
    ASTNode expr;
    
    this(string op, ASTNode expr) {
        this.op = op;
        this.expr = expr;
    }
    
    override string toString() const {
        return "UnaryExpr(" ~ op ~ ", " ~ expr.toString() ~ ")";
    }
}

// AST node for postfix expressions (e.g., expr++)
class PostfixExpr : ASTNode {
    string op;
    ASTNode target;
    
    this(string op, ASTNode target) {
        this.op = op;
        this.target = target;
    }
    
    override string toString() const {
        return "PostfixExpr(" ~ target.toString() ~ op ~ ")";
    }
}

// AST node for binary expressions (e.g., a + b)
class BinaryExpr : ASTNode {
    string op;
    ASTNode left;
    ASTNode right;
    
    this(string op, ASTNode left, ASTNode right) {
        this.op = op;
        this.left = left;
        this.right = right;
    }
    
    override string toString() const {
        return "BinaryExpr(" ~ left.toString() ~ " " ~ op ~ " " ~ right.toString() ~ ")";
    }
}

// AST node for member expressions (e.g., obj.member)
class MemberExpr : ASTNode {
    ASTNode object;
    string member;
    
    this(ASTNode object, string member) {
        this.object = object;
        this.member = member;
    }
    
    override string toString() const {
        return "MemberExpr(" ~ object.toString() ~ "." ~ member ~ ")";
    }
}

// AST node for method call expressions using UFCS
class MemberCallExpr : ASTNode {
    ASTNode object;
    string method;
    ASTNode[] arguments;
    
    this(ASTNode object, string method, ASTNode[] arguments) {
        this.object = object;
        this.method = method;
        this.arguments = arguments;
    }
    
    override string toString() const {
        string result = "MemberCallExpr(" ~ object.toString() ~ "." ~ method ~ "(";
        foreach (i, arg; arguments) {
            if (i > 0) result ~= ", ";
            result ~= arg.toString();
        }
        result ~= "))";
        return result;
    }
}

// AST node for array access expressions (e.g., arr[idx])
class ArrayAccessExpr : ASTNode {
    string arrayName;
    ASTNode index;
    ASTNode baseExpr;  // For multidimensional arrays: base[idx] or for complex bases: (expr)[idx]
    
    this(string arrayName, ASTNode index) {
        this.arrayName = arrayName;
        this.index = index;
    }
    
    this(ASTNode baseExpr, ASTNode index) {
        this.baseExpr = baseExpr;
        this.index = index;
        
        // Try to extract array name for simple cases
        if (auto varExpr = cast(VarExpr) baseExpr) {
            this.arrayName = varExpr.name;
        }
    }
    
    override string toString() const {
        if (baseExpr !is null) {
            return "ArrayAccessExpr(" ~ baseExpr.toString() ~ "[" ~ index.toString() ~ "])";
        } else {
            return "ArrayAccessExpr(" ~ arrayName ~ "[" ~ index.toString() ~ "])";
        }
    }
}

// AST node for struct field access
class StructFieldAccess : ASTNode {
    ASTNode baseExpr;
    string field;
    
    this(ASTNode baseExpr, string field) {
        this.baseExpr = baseExpr;
        this.field = field;
    }
    
    override string toString() const {
        return "StructFieldAccess(" ~ baseExpr.toString() ~ "." ~ field ~ ")";
    }
}

// AST node for function calls
class CallExpr : ASTNode {
    string name;
    ASTNode[] args;
    ASTNode callee; // For expressions like (expr)(args)
    
    this(string name, ASTNode[] args) {
        this.name = name;
        this.args = args;
    }
    
    this(ASTNode callee, ASTNode[] args) {
        this.callee = callee;
        this.args = args;
        
        // Extract name for simple variable callees
        if (auto varExpr = cast(VarExpr) callee) {
            this.name = varExpr.name;
        } else if (auto memberExpr = cast(MemberExpr) callee) {
            // For method calls obj.method()
            this.name = memberExpr.member;
        }
    }
    
    override string toString() const {
        string result = "CallExpr(";
        if (callee !is null) {
            result ~= callee.toString();
        } else {
            result ~= name;
        }
        result ~= "(";
        foreach (i, arg; args) {
            if (i > 0) result ~= ", ";
            result ~= arg.toString();
        }
        result ~= "))";
        return result;
    }
}

// AST node for cast expressions
class CastExpr : ASTNode {
    string type;
    ASTNode expr;
    
    this(string type, ASTNode expr) {
        this.type = type;
        this.expr = expr;
    }
    
    override string toString() const {
        return "CastExpr(" ~ type ~ ", " ~ expr.toString() ~ ")";
    }
}

// AST node for statements that are just expressions
class ExprStmt : ASTNode {
    ASTNode expr;
    
    this(ASTNode expr) {
        this.expr = expr;
    }
    
    override string toString() const {
        return "ExprStmt(" ~ expr.toString() ~ ")";
    }
}

// AST node for blocks of statements (e.g., { stmt1; stmt2; })
class BlockStmt : ASTNode {
    ASTNode[] blockBody;
    
    this(ASTNode[] blockBody) {
        this.blockBody = blockBody;
    }
    
    override string toString() const {
        string result = "BlockStmt({\n";
        foreach (stmt; blockBody) {
            result ~= "  " ~ stmt.toString() ~ ";\n";
        }
        result ~= "})";
        return result;
    }
}

// AST node for if statements
class IfStmt : ASTNode {
    ASTNode condition;
    ASTNode[] thenBody;
    ASTNode[] elseBody;
    
    this(ASTNode condition, ASTNode[] thenBody, ASTNode[] elseBody) {
        this.condition = condition;
        this.thenBody = thenBody;
        this.elseBody = elseBody;
    }
    
    override string toString() const {
        string result = "IfStmt(if (" ~ condition.toString() ~ ") {\n";
        foreach (stmt; thenBody) {
            result ~= "  " ~ stmt.toString() ~ ";\n";
        }
        result ~= "}";
        
        if (elseBody.length > 0) {
            result ~= " else {\n";
            foreach (stmt; elseBody) {
                result ~= "  " ~ stmt.toString() ~ ";\n";
            }
            result ~= "}";
        }
        
        result ~= ")";
        return result;
    }
}

// AST node for while statements
class WhileStmt : ASTNode {
    ASTNode condition;
    ASTNode[] loopBody;
    
    this(ASTNode condition, ASTNode[] loopBody) {
        this.condition = condition;
        this.loopBody = loopBody;
    }
    
    override string toString() const {
        string result = "WhileStmt(while (" ~ condition.toString() ~ ") {\n";
        foreach (stmt; loopBody) {
            result ~= "  " ~ stmt.toString() ~ ";\n";
        }
        result ~= "})";
        return result;
    }
}

// AST node for C-style for loops
class CStyleForStmt : ASTNode {
    ASTNode init;       // initialization
    ASTNode condition;  // condition
    ASTNode increment;  // increment
    ASTNode[] forBody;  // body statements
    
    this(ASTNode init, ASTNode condition, ASTNode increment, ASTNode[] forBody) {
        this.init = init;
        this.condition = condition;
        this.increment = increment;
        this.forBody = forBody;
    }
    
    override string toString() const {
        string result = "ForStmt(for (";
        if (init !is null) result ~= init.toString();
        result ~= "; ";
        if (condition !is null) result ~= condition.toString();
        result ~= "; ";
        if (increment !is null) result ~= increment.toString();
        result ~= ") {\n";
        
        foreach (stmt; forBody) {
            result ~= "  " ~ stmt.toString() ~ ";\n";
        }
        result ~= "})";
        return result;
    }
}

// AST node for foreach statements
class ForeachStmt : ASTNode {
    string varName;      // iteration variable
    ASTNode iterable;    // iterable expression (array, range, etc.)
    ASTNode[] forEachBody;  // body statements
    
    this(string varName, ASTNode iterable, ASTNode[] forEachBody) {
        this.varName = varName;
        this.iterable = iterable;
        this.forEachBody = forEachBody;
    }
    
    override string toString() const {
        string result = "ForeachStmt(foreach (" ~ varName ~ "; " ~ iterable.toString() ~ ") {\n";
        foreach (stmt; forEachBody) {
            result ~= "  " ~ stmt.toString() ~ ";\n";
        }
        result ~= "})";
        return result;
    }
}

// AST node for function declarations
class FunctionDecl : ASTNode {
    string name;
    string returnType;
    Parameter[] params;
    ASTNode[] funcBody;
    
    this(string name, string returnType, Parameter[] params, ASTNode[] funcBody) {
        this.name = name;
        this.returnType = returnType;
        this.params = params;
        this.funcBody = funcBody;
    }
    
    override string toString() const {
        string result = "FunctionDecl(" ~ returnType ~ " " ~ name ~ "(";
        foreach (i, param; params) {
            if (i > 0) result ~= ", ";
            result ~= param.toString();
        }
        result ~= ") {\n";
        
        foreach (stmt; funcBody) {
            result ~= "  " ~ stmt.toString() ~ ";\n";
        }
        result ~= "})";
        return result;
    }
}

// Helper class for function parameters
class Parameter {
    string type;
    string name;
    
    this(string type, string name) {
        this.type = type;
        this.name = name;
    }
    
    string toString() const {
        return type ~ " " ~ name;
    }
}

// AST node for return statements
class ReturnStmt : ASTNode {
    ASTNode value;
    
    this(ASTNode value) {
        this.value = value;
    }
    
    override string toString() const {
        return "ReturnStmt(return " ~ (value !is null ? value.toString() : "") ~ ")";
    }
}

// AST node for print statements
class PrintStmt : ASTNode {
    ASTNode[] values;
    
    this(ASTNode[] values) {
        this.values = values;
    }
    
    override string toString() const {
        string result = "PrintStmt(print ";
        foreach (i, v; values) {
            if (i > 0) result ~= ", ";
            result ~= v.toString();
        }
        result ~= ")";
        return result;
    }
}

// AST node for assignment statements (separate from expressions for clarity)
class AssignStmt : ASTNode {
    ASTNode lhs;
    ASTNode value;
    
    this(ASTNode lhs, ASTNode value) {
        this.lhs = lhs;
        this.value = value;
    }
    
    override string toString() const {
        return "AssignStmt(" ~ lhs.toString() ~ " = " ~ value.toString() ~ ")";
    }
}

// AST node for break statements
class BreakStmt : ASTNode {
    override string toString() const {
        return "BreakStmt(break)";
    }
}

// AST node for continue statements
class ContinueStmt : ASTNode {
    override string toString() const {
        return "ContinueStmt(continue)";
    }
}

// AST node for switch statements
class SwitchStmt : ASTNode {
    ASTNode condition;
    ASTNode[] cases;  // List of CaseStmt
    
    this(ASTNode condition, ASTNode[] cases) {
        this.condition = condition;
        this.cases = cases;
    }
    
    override string toString() const {
        string result = "SwitchStmt(switch (" ~ condition.toString() ~ ") {\n";
        foreach (c; cases) {
            result ~= "  " ~ c.toString() ~ "\n";
        }
        result ~= "})";
        return result;
    }
}

// AST node for case statements within switch
class CaseStmt : ASTNode {
    ASTNode condition;  // null for default case
    ASTNode[] caseBody;
    
    this(ASTNode condition, ASTNode[] caseBody) {
        this.condition = condition;
        this.caseBody = caseBody;
    }
    
    override string toString() const {
        string result;
        if (condition is null) {
            result = "CaseStmt(default: {\n";
        } else {
            result = "CaseStmt(case " ~ condition.toString() ~ ": {\n";
        }
        
        foreach (stmt; caseBody) {
            result ~= "  " ~ stmt.toString() ~ ";\n";
        }
        result ~= "})";
        return result;
    }
}

// AST node for mixin templates (D feature) - serves as a defined template
class MixinTemplate : ASTNode {
    string name;
    ASTNode[] templateBody;
    
    this(string name, ASTNode[] templateBody) {
        this.name = name;
        this.templateBody = templateBody;
    }
    
    override string toString() const {
        string result = "MixinTemplate(" ~ name ~ " {\n";
        foreach (stmt; templateBody) {
            result ~= "  " ~ stmt.toString() ~ ";\n";
        }
        result ~= "})";
        return result;
    }
}

// AST node for using/inserting a template mixin
class TemplateMixin : ASTNode {
    string templateName;
    
    this(string templateName) {
        this.templateName = templateName;
    }
    
    override string toString() const {
        return "TemplateMixin(mixin " ~ templateName ~ ")";
    }
}

// AST node for string mixins (dynamic code generation in D)
class StringMixin : ASTNode {
    ASTNode stringExpr;
    
    this(ASTNode stringExpr) {
        this.stringExpr = stringExpr;
    }
    
    override string toString() const {
        return "StringMixin(mixin(" ~ stringExpr.toString() ~ "))";
    }
}

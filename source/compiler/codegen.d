// compiler/codegen.d
module compiler.codegen;

import compiler.ast;
import compiler.instructions;
import std.file;
import std.string;

private struct Instructions {
	string arithmetic = "Arithmetic operation";
}

private Instructions instructions;

class CodeGenerator {
    string generate(ASTNode node) {
        string code = generateHeaders();
		
		// 1. inject custom functions
		code ~= loadCustomFunctions();
		
		// 2. generate main code
		if (auto fn = cast(FunctionDecl)node) {
			code ~= generateFunction(fn);
		}
		else if (auto vb = cast(VarBlock)node) {
			code ~= generateVarBlock(vb);
		}
		else {
			import std.stdio;
			stderr.writeln("Error: Unsupported AST node type");
		}
		
		code ~= generateFooter();
		return code;
    }
    
	private string generateHeaders() {
		return
		"* ---------------------------------------------
		* Generated by D2GEN Compiler\n
		* ---------------------------------------------
			ORG 	$1000
		START: 			;= First instruction
		";
	}
	
	private string generateFooter() {
		return
		"SIMHALT		; Halt simulator
		END		START		; End of program
		";
	}
	
    private string generateFunction(FunctionDecl fn) {
        string asmCode;
        
        // Function header
        asmCode ~= format("_%s:\n", fn.name);  // Leading underscore for C compatibility
        asmCode ~= "        link    a6,#0\n";  // Setup stack frame
        
        // Generate body
        foreach (stmt; fn.bodyStatements) {
			asmCode ~= " 		" ~ generateStatement(stmt); // indent body
        }
        
        // Function footer
        asmCode ~= "        unlk    a6\n";     // Restore stack frame
        asmCode ~= "        rts\n";            // Return from subroutine
        return asmCode;
    }
    
    private string generateReturn(ReturnStmt stmt) {
        if (auto lit = cast(Literal)stmt.expression) {
            return format("        move.l  #%s,d0\n", lit.value);  // Return value in d0
        }
        return "";
    }
    
	private string generateVarBlock(VarBlock vb) {
		string asmCode;
		foreach (decl; vb.declarations) {
			if (auto lit = cast(Literal)decl.initialValue) {
				asmCode ~= format("		move.l #%s, %s\n", lit.value, decl.name);
			}
		}
		return asmCode;
	}
	
	private string generateExpression(Expression expr) {
		if (auto lit = cast(Literal)expr) {
			return format("		move.l #%s, d0\n", lit.value);
		}
		else if (auto binop = cast(BinaryOp)expr) {
			string asmCode;
			asmCode ~= generateExpression(binop.left);
			asmCode ~= " 	move.l d0, -(sp)\n"; // save left operand
			asmCode ~= generateExpression(binop.right);
			asmCode ~= "	move.l (sp)+, d1\n"; // restore left to d1
			
			switch (binop.op) {
				case "+": asmCode ~= "	add.l	d1, d0\n"; break;
				case "-": asmCode ~= "	sub.l	d1, d0\n"; break;
				case "*": asmCode ~= "	mul.l	d1, d0\n"; break;
				case "/": asmCode ~= "	div.l 	d1, d0\n"; break;
				// add more later
				default: asmCode ~= "; Unknown operator\n";
			}
			return asmCode;
		}
		return "";
	}
	
	private string generateStatement(ASTNode stmt) {
		string asmCode;
		
		final switch (stmt.nodeType) {
			case "ReturnStmt":
				asmCode ~= generateReturn(cast(ReturnStmt)stmt);
				break;
			
			case "VarDecl":
				asmCode ~= generateVarDecl(cast(VarDecl)stmt);
				break;
				
			case "ExpressionStmt":
				asmCode ~= generateExpression((cast(ExpressionStmt)stmt).expr);
				break;
			
			case "IfStmt":
				asmCode ~= generateIf(cast(IfStmt)stmt);
				break;
				
			case "WhileStmt":
				asmCode ~= generateWhile(cast(WhileStmt)stmt);
				break;
				
			case "VarBlock":
				foreach (decl; (cast(VarBlock)stmt).declarations) {
					asmCode ~= generateVarDecl(decl);
				}
				break;
		}
		
		return asmCode;
	}
	
	private string generateVarDecl(VarDecl decl) {
		string asmCode;
		if (auto lit = cast(Literal)decl.initialValue) {
			asmCode ~= format("		move.l #%s, %s\n", lit.value, decl.name);
		}
		else if (auto expr = cast(Expression)decl.initialValue) {
			asmCode ~= generateExpression(expr);
			asmCode ~= format("		move.l d0, %s\n", decl.name);
		}
		else {
			asmCode ~= format("; Unsupported initializer for %s\n", decl.name);
		}
		
		return asmCode;
	}
	
	private string generateIf(IfStmt ifStmt) {
		static int labelCounter = 0;
		string asmCode;
		string elseLabel = format("else_%d", labelCounter);
		string endLabel = format("endif_%d", labelCounter++);
		
		// condition
		asmCode ~= generateExpression(ifStmt.condition);
		asmCode ~= " 	tst.l 	d0\n";
		asmCode ~= format("		beq		%s\n", elseLabel);
		
		// then branch
		asmCode ~= generateStatement(ifStmt.thenBranch);
		
		// else branch if it exists
		if (ifStmt.elseBranch !is null) {
			asmCode ~= format("		bra 	%s\n", endLabel);
			asmCode ~= format("%s:\n", elseLabel);
			asmCode ~= generateStatement(ifStmt.elseBranch);
		}
		else {
			asmCode ~= format("%s:\n", elseLabel);
		}
		
		asmCode ~= format("%s:\n", endLabel);
		return asmCode;
	}
	
	private string generateWhile(WhileStmt whileStmt) {
		static int labelCounter = 0;
		string asmCode;
		string startLabel = format("while_%d", labelCounter);
		string endLabel = format("endwhile_%d", labelCounter++);
		
		asmCode ~= format("%s\n", startLabel);
		
		// condition
		asmCode ~= generateExpression(whileStmt.condition);
		asmCode ~= "	tst.l	d0\n";
		asmCode ~= format("		beq		%s\n", endLabel);
		
		// body
		asmCode ~= generateStatement(whileStmt.condition);
		asmCode ~= format("		bra		%s\n", startLabel);
		
		asmCode ~= format("%s:\n", endLabel);
		return asmCode;
	}
	
	private string generateInstuction(Instruction instr) {
		string asmCode;
		final switch (instr.type) {
			case "mul":
				// works for easy68k and genesis
				asmCode ~= format("		move.%s %s, -(sp)\n",
					instr.size == 32 ? "l" : "w", instr.src);
				asmCode ~= format("		move.%s %s, %s\n",
					instr.size == 32 ? "l" : "w", instr.dest, instr.src);
				asmCode ~= format("		%s.%s %s, -(sp)\n", instr.isSigned ? "muls" : "mulu",
					instr.size == 32 ? "l" : "w", instr.dest, instr.src);
					
				break;
			
			case "move":
				// size-agonistic (.w for easy68k, .l for genesis)
				asmCode ~= format("		move.%s %s, %s\n",
					instr.size == 32 ? "l" : "w", instr.src, instr.dest);
				break;
		}
		return asmCode;
	}
	
	string generateAdd(string dst, string src) {
    return format("    ADD_L  %s,%s  ; %s\n", 
                 dst, src, instructions.arithmetic);
	}

	// In codegen.d
	string generateBinaryOp(BinaryOp op) {
		import compiler.instructions;
		
		final switch(op.op) {
			case "+":
				return genAdd(generateExpression(op.left), generateExpression(op.right));
			case "*":
				return "    " ~ instructions.arithmetic ~ "\n" ~ 
					format("    MULS_W  %s,%s\n", op.left, op.right);
			case "-":
				return "    " ~ instructions.arithmetic ~ "\n" ~ 
					format("    SUB.W  %s,%s\n", op.left, op.right);
			case "/":
				return "    " ~ instructions.arithmetic ~ "\n" ~ 
					format("    DIVS.W  %s,%s\n", op.left, op.right);
		}
	}
	
    void emitToFile(string filename, string content) {
        filename.write(content);
    }
	
	private string loadCustomFunctions() {
		import std.path;
		string customCode;
		foreach (file; dirEntries("lib", "*.dgen", SpanMode.shallow)) {
			customCode ~= readText(file) ~ "\n";
			customCode ~= "		; Loaded from : " ~ file.baseName ~ "\n";
		}
		return customCode;
	}
}
